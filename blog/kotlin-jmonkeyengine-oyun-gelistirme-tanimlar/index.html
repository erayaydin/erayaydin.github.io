<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>Kotlin ve jMonkeyEngine ile Oyun Geliştirme - Tanımlar</title><meta content="Eray Aydın" name=author><meta content="Bu serinin ilk yazısında, Kotlin ve jMonkeyEngine ile oyun geliştirmeye başlamadan önce tanmlara göz atacağız" name=description><link href=https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/ rel=canonical><link rel="shortcut icon" href=https://era.yayd.in/favicon.png type=image/x-icon><meta content=website property=og:type><meta content=https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/ property=og:url><meta content="Eray Aydın" property=og:site_name><meta content="Kotlin ve jMonkeyEngine ile Oyun Geliştirme - Tanımlar" property=og:title><meta content="Bu serinin ilk yazısında, Kotlin ve jMonkeyEngine ile oyun geliştirmeye başlamadan önce tanmlara göz atacağız" property=og:description><link href=https://era.yayd.in/atom.xml rel=alternate title=RSS type=application/atom+xml><link href=https://era.yayd.in/app.css rel=stylesheet><style></style><body><header><nav><a href=/> /home </a><a href=/about/> /about </a><a href=/journal/> /journal </a><a class=active href=/blog/> /blog </a><a href=https://github.com/erayaydin/erayaydin.github.io> /download </a><div><input id=themeToggle style=display:none type=checkbox><label for=themeToggle><svg class=icons id=themeIcon><use href=https://era.yayd.in/icons.svg#lightMode></use></svg></label><audio id=themeSound><source src=https://era.yayd.in/click.ogg type=audio/ogg></audio></div></nav></header><main><div><a href=..>..</a>/<span class=accent-data>kotlin-jmonkeyengine-oyun-gelistirme-tanimlar</span></div><time datetime=2020-03-22T05:01:53>Published on: <span class=accent-data>2020-03-22T05:01:53</span></time><address rel=author>By <span class=accent-data>Eray Aydın</span></address><h1>Kotlin ve jMonkeyEngine ile Oyun Geliştirme - Tanımlar</h1><hr><blockquote><p>You are reading an article that is more than a year old. The content might be outdated.</blockquote><hr><h2 id=toc>Table of contents</h2><ul><li><a href=https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#kotlin-ve-jmonkeyengine-ile-oyun-gelistirme-tanimlar>Kotlin ve jMonkeyEngine ile Oyun Geliştirme - Tanımlar</a> <ul><li><a href=https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#kotlin-nedir>Kotlin Nedir?</a> <ul></ul><li><a href=https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#jmonkeyengine-nedir>jMonkeyEngine Nedir?</a> <ul><li><a href=https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#jmonkeyengine-3-sdk-jmonkeyplatform>jMonkeyEngine 3 SDK (jMonkeyPlatform)</a><li><a href=https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#lwjgl-lightweight-java-game-library>LWJGL (Lightweight Java Game Library)</a><li><a href=https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#bullet-physics>Bullet Physics</a><li><a href=https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#nifty-gui>Nifty GUI</a></ul><li><a href=https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#gradle>Gradle</a> <ul></ul><li><a href=https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#graphic-pipeline>Graphic Pipeline</a> <ul><li><a href=https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#genel-yapi>Genel Yapı</a></ul><li><a href=https://era.yayd.in/blog/kotlin-jmonkeyengine-oyun-gelistirme-tanimlar/#scene-graph>Scene Graph</a> <ul></ul></ul></ul><hr><div class=page-content><h1 id=kotlin-ve-jmonkeyengine-ile-oyun-gelistirme-tanimlar><a aria-label="Anchor link for: kotlin-ve-jmonkeyengine-ile-oyun-gelistirme-tanimlar" class=no-style href=#kotlin-ve-jmonkeyengine-ile-oyun-gelistirme-tanimlar>#</a> Kotlin ve jMonkeyEngine ile Oyun Geliştirme - Tanımlar</h1><p>Merhaba, Bu yazı serisi içerisinde <strong>Kotlin</strong> ve <strong>jMonkeyEngine</strong> ile oyun geliştirme yöntemine bakacağız. Seri içerisinde sorunuz olursa sormaktan çekinmeyin. Sorularınızı issue olarak Github üzerinden açabilirsiniz.<blockquote><p>Not: <strong>Kotlin</strong> tecrübem hiç denecek kadar azdır, bu sebeple hata yaptığım noktalar olursa şimdiden özür dilerim. Hataları Git reposunda düzelterek PR oluşturabilirsiniz :)</blockquote><p>Şimdi <strong>kısaca</strong> jMonkeyEngine, Kotlin, Gradle, Graphic Pipeline ve Scene Graph kavramlarına bakacağız.<h2 id=kotlin-nedir><a aria-label="Anchor link for: kotlin-nedir" class=no-style href=#kotlin-nedir>##</a> Kotlin Nedir?</h2><p>Kotlin; statik, nesneye yönelimli özgür bir fonksiyonel programlama dilidir. Java ile birlikte çalışacak şekilde geliştirilmiştir lakin çok daha “hoş” bir syntax yapısı ile geliştirme yapmanıza olanak sağlamakta. Konsept olarak JVM için kullanılmakta olsa da artık LLVM ile mobil native ve JS için de geliştirmede kullanılmakta. Birden çok platformu desteklemesine rağmen jMonkeyEngine ile oyun geliştirirken bu seride Kotlin JVM’i kullanarak ilerleyeceğiz bu sebeple Kotlin ile gelen cross-platform özelliğini kullanmayacağız. JVM ile çalıştırdığımız için JVM’in cross-platform özelliği seri içerisinde devam etmekte.<p>Yararlanabileceğiniz kaynaklar:<ul><li><a href=https://kotlinlang.org/ rel=noopener target=_blank>Kotlin Website</a><li><a href=https://kotlinlang.org/docs/tutorials/kotlin-for-py/introduction.html rel=noopener target=_blank>Python tecrübesi olanlar için resmi Kotlin dersleri</a><li><a href=https://medium.com/@halilozel1903/kotlin-nedir-43e312d2dca6 rel=noopener target=_blank>Halil Özel’den Kotlin Nedir?</a><li><a href=https://www.mobilhanem.com/kotlin-egitimleri/ rel=noopener target=_blank>Mobil Hanem - Kotlin Eğitimi</a></ul><h2 id=jmonkeyengine-nedir><a aria-label="Anchor link for: jmonkeyengine-nedir" class=no-style href=#jmonkeyengine-nedir>##</a> jMonkeyEngine Nedir?</h2><p>jMonkeyEngine, Java ile yazılmış bir modern 3D geliştirme sağlayan bir oyun motorudur. Varsayılan olarak <em>LWJGL(Lightweight Java Game Library)</em> renderer paketini kullanmaktadır. Elbetteki kendi renderer paketinizi veya birbaşka 3. parti renderer paketini de kolayca enjekte edebilirsiniz. <em>LWJGL</em> ile OpenGL2+ sürümleri desteklenmektedir. Bu da oldukça geniş bir yelpaze demek. Alt başlıklar halinde; <em>jMonkeyEngineSDK</em>, <em>LWJGL</em>, <em>Bullet Physics</em>, <em>NiftyGUI</em> parçalarını inceleyeceğiz.<ul><li><a href=https://github.com/jMonkeyEngine/jmonkeyengine/releases rel=noopener target=_blank>jMonkeyEngine sürümleri ve indirme</a> (İndirme yapmanıza gerek yok, jMonkeyEngine 3 SDK ile devam edecekseniz zaten kurulu gelecektir. Bir sonraki yazıda Gradle ile inşa mekanizmasını hazırlarken de jMonkeyEngine paketini indirteceğiz.)</ul><p>Yararlanabileceğiniz kaynaklar:<ul><li><a href=https://jmonkeyengine.org/ rel=noopener target=_blank>jMonkeyEngine Website</a><li><a href=https://wiki.jmonkeyengine.org/ rel=noopener target=_blank>jMonkeyEngine Wiki</a><li><a href=https://javadoc.jmonkeyengine.org/v3.x/index.html rel=noopener target=_blank>JavaDoc</a><li><a href=https://hub.jmonkeyengine.org/ rel=noopener target=_blank>Forum</a></ul><h3 id=jmonkeyengine-3-sdk-jmonkeyplatform><a aria-label="Anchor link for: jmonkeyengine-3-sdk-jmonkeyplatform" class=no-style href=#jmonkeyengine-3-sdk-jmonkeyplatform>###</a> jMonkeyEngine 3 SDK (jMonkeyPlatform)</h3><p>jMonkeyEngine 3 sürümü ile gelen <code>jMonkeyEngine 3 SDK</code>, Netbeans tabanlı olan bu geliştirme ortamı eklenti desteği ve grafiksel geliştirme sağlamaktadır. İçerisinde, Sahne Editörü (Scene Editor), Materyal Editörü (Material Editor), Filtreleme Editörü (Filter Editor), dahili Blender ve dahili JDK bulunmaktadır.<p>Seri içerisinde olabildiğince <code>Intellij IDEA</code> ve <code>jMonkeyEngine 3 SDK</code> için anlatım yapmaya çalışacağım lakin sorun oluşturabilecek noktalarda <code>Intellij IDEA</code> üzerinden geliştirmeye devam edeceğim. Bu seri içerisindeki anlatımları bu IDE’lerden birinden veya beğendiğiniz başka bir IDE veya metin editörü ile uygulayabilirsiniz.<ul><li><a href=https://github.com/jMonkeyEngine/sdk/releases/ rel=noopener target=_blank>SDK Versiyonları ve İndirme (GNU/Linux, Windows, OSX ve Kaynak</a></ul><h3 id=lwjgl-lightweight-java-game-library><a aria-label="Anchor link for: lwjgl-lightweight-java-game-library" class=no-style href=#lwjgl-lightweight-java-game-library>###</a> LWJGL (Lightweight Java Game Library)</h3><p>LWJGL, Java ile yazılmış bir oyun kütüphanesidir. Cross-platform olarak grafik (OpenGL, Vulkan), ses(OpenAL) ve paralel hesaplama(OpenCL) uygulamaları geliştirmenize yardımcı olmaktadır.<p>Dilerseniz geliştirmenizi LWJGL ve 3. parti yardımcı olacak paketlerle (GUI, Physic paketleri, Networking paketleri vs) yaparak daha low-level devam edebilirsiniz. Bu seri içerisindeki anlatımlar jMonkeyEngine odaklı olacağı için pek faydası olmayacaktır lakin göz atıp fikir almak da faydalı olur elbette :)<ul><li><a href=https://www.lwjgl.org/ rel=noopener target=_blank>Website</a><li><a href=https://www.lwjgl.org/guide rel=noopener target=_blank>Guide</a><li><a href=https://github.com/LWJGL/lwjgl3/tree/master/modules/samples/src/test/java/org/lwjgl/demo rel=noopener target=_blank>Örnekler</a></ul><h3 id=bullet-physics><a aria-label="Anchor link for: bullet-physics" class=no-style href=#bullet-physics>###</a> Bullet Physics</h3><p>Bullet, C&C++ ile geliştirilmiş bir fizik motorudur. Çarpışma hesaplama (collision detection), hareket ve diğer fizik işlemlerini sağlayan bir pakettir.<p>jMonkeyEngine, jBullet (Bullet’in Java’ya göre yazılmış hali) kullanarak fizik mekaniği sağlamaktadır.<ul><li><a href=https://github.com/bulletphysics/bullet3 rel=noopener target=_blank>Bullet Physics SDK</a><li><a href=http://jbullet.advel.cz/ rel=noopener target=_blank>jBullet</a></ul><h3 id=nifty-gui><a aria-label="Anchor link for: nifty-gui" class=no-style href=#nifty-gui>###</a> Nifty GUI</h3><p>Nifty GUI, Java ile yazılmış bir GUI geliştirme paketidir. Çizim kısmında OpenGL kullanmaktadır lakin elbette bu render kısmına müdahale edip başka bir renderer wrapper yazarak injekte edebilirsiniz.<ul><li><a href=https://github.com/nifty-gui/nifty-gui rel=noopener target=_blank>Git Depo</a></ul><h2 id=gradle><a aria-label="Anchor link for: gradle" class=no-style href=#gradle>##</a> Gradle</h2><p>Java, Groovy ve Kotlin ile yazılmış bir build mekanizmasıdır. Maven’deki gibi XML yazım biçimi yerine Groovy tarzında build otomasyonu oluşturmanızı sağlar. Paketlerimizi Gradle ile belirleyip, inşa mekanizmasını kullanacağız.<ul><li><a href=https://gradle.org/ rel=noopener target=_blank>Website</a><li><a href=https://github.com/gradle/gradle rel=noopener target=_blank>Git Depo</a></ul><h2 id=graphic-pipeline><a aria-label="Anchor link for: graphic-pipeline" class=no-style href=#graphic-pipeline>##</a> Graphic Pipeline</h2><p>3 Boyutlu bir ortamın, 2 boyutlu ekrana getirilmesindeki süreci özetleyen kavrama “Graphic Pipeline” denmektedir. Oyunumuzu 3 boyutlu ortamda geliştireceğimiz için, grafiğin hazırlanma süreci hakkında bilgi sahibi olmak da önemlidir. Özellikle daha düşük seviyeli ortamlarda (LWJGL veya direk bir grafik API kullanarak) geliştirme yapanların muhakkak bilgi sahibi olması gereken bir kavramdır. Hem yazılımsal hem de donanımsal bir süreç gerektiren bu yolculuk için herkes tarafından benimsenmiş bir yol bulunmamaktadır. Lakin, Direct3D ve OpenGL gibi grafik kütüphaneleri, donanım hızlandırması sağlamak amaçlı bu süreçlerdeki benzer adımları ortaklaştırmıştır. Yani, geliştiricinin grafik hızlandırmayı kullanması için donanıma direk müdahalesi yerine bunu soyutlayarak kullanmasını amaçlamaktadır.<p>Bu konuda, şu videoyu izlemenizi tavsiye ederim: <a href="https://www.youtube.com/watch?v=bgckX62f4EA" rel=noopener target=_blank>thebennybox - Intro to Modern OpenGL Tutorial: Graphics Pipeline</a><h3 id=genel-yapi><a aria-label="Anchor link for: genel-yapi" class=no-style href=#genel-yapi>###</a> Genel Yapı</h3><p>Genel yapıda çizimin oluşması ve ekrana gelmesi için 3 adım bulunmaktadır:<ol><li>Application (Uygulama)<li>Geometry (Geometri)<li>Rasterization (Pikselleştirme)</ol><h4 id=1-application-uygulama><a aria-label="Anchor link for: 1-application-uygulama" class=no-style href=#1-application-uygulama>####</a> 1. Application (Uygulama)</h4><p>Uygulama tarafından hesaplanan çizimin (bütün collision hesaplaması, çizilecek nesnelerin noktası, üçgenleri vs) belirlenip pipeline’da bir sonraki adıma iletilmesidir.<h4 id=2-geometry-geometri><a aria-label="Anchor link for: 2-geometry-geometri" class=no-style href=#2-geometry-geometri>####</a> 2. Geometry (Geometri)</h4><p>Geometri adımında, Model & Camera’nin yerleştirilmesi, ışıklandırmanın hesaplanması, projeksiyonun hesaplanması, clipping (uzak/yakın) ve pencereye göre konumlandırılması adımları yer almaktadır.<h4 id=3-rasterization-piksellestirme><a aria-label="Anchor link for: 3-rasterization-piksellestirme" class=no-style href=#3-rasterization-piksellestirme>####</a> 3. Rasterization (Pikselleştirme)</h4><p>Piksel içerisindeki rengi belirleyen adımdır. Çizilecek nesnenin her bir noktası için bu pikselleştirme yapılmaktadır (eğer varsa; Fragment Shader bu adım içerisinde devreye alınmaktadır).<h4 id=opengl-rendering-pipeline><a aria-label="Anchor link for: opengl-rendering-pipeline" class=no-style href=#opengl-rendering-pipeline>####</a> OpenGL Rendering Pipeline</h4><p>Örnek olarak, OpenGL’in Rendering Pipeline’ı açıklamak gerekirse;<ol><li>Vertex Spec (OpenGL)<li>Vertex Shader (Programcı tarafından müdahale edilebilir)<li>Tessellation (Opsiyonel olarak, programcı tarafından müdahale edilebilir)<li>Geometry Shader (Opsiyonel olarak, programcı tarafından müdahale edilebilir)<li>Vertex Post-Processing (OpenGL)<li>Primitive Assembly (OpenGL)<li>Rasterization (OpenGL)<li>Fragment Shader (Opsiyonel olarak, programcı tarafından müdahale edilebilir)<li>Per-Sample Ops (OpenGL)</ol><p>Burada programcının çizimin donanımsal hızlandırma kullanması için müdahale etmesini sağlamaktadır. Vertex Shader, Geometry Shader ve Fragment Shader’ı GLSL dili ile yazarak donanıma yapması gereken işlevi söyleme işidir.<blockquote><p>Bu konuda, şu videoyu izlemenizi tavsiye ederim: <a href="https://www.youtube.com/watch?v=bgckX62f4EA" rel=noopener target=_blank>thebennybox - Intro to Modern OpenGL Tutorial: Graphics Pipeline</a></blockquote><h2 id=scene-graph><a aria-label="Anchor link for: scene-graph" class=no-style href=#scene-graph>##</a> Scene Graph</h2><p>jMonkeyEngine ile oyun geliştirirken bu kavramı sıkça duyacağız. Oyunumuzu geliştirirken kurguladığımız sanal ortama <strong>scene graph</strong> denmektedir. Bu sanal sahnemizdeki her bir objemize de <strong>Spatial</strong> diyeceğiz. Bu <em>spatial</em> nesnelerimizin her birinde de <strong>translation</strong>(konum), <strong>rotation</strong>(baktığı yön) ve <strong>scale</strong>(büyüklük) bilgisi bulunacaktır. Buradaki <strong>translation</strong> konum, 3 boyuttan aşina olduğumuz X,Y ve Z kavramları ile belirtilmektedir.<p>Bu sahnemizi kurgularken farklı obje türüne ihtiyacımız olacaktır. Tahmin edebileceğiniz gibi, sahnemiz içerisinde görünmesini istediğimiz objeler olacağı gibi görünmesini istemediğimiz ve konum/baktığı yön/büyüklük gibi değerlerini kullanacağımız objeler de yer alacaktır. Varsayılan olarak oluşturduğumuz bi <strong>spatial</strong> nesneler görünmez durumdadır ve sadece bu bahsettiğim bilgileri tutmaktadır. Lakin <strong>Geometry</strong> türünde olan <strong>spatial</strong> nesneler ise, şekli olan ve görülebilir nesnelerdir. Şekillerini <strong>mesh</strong> ler belirtmekte ve <strong>material</strong> ler ile de görüntüsünü almaktadır.<p>Bir diğer husus da <strong>spatial</strong> nesnelerin yönetimi. Kurgu hazırladığımız için bir süre sonra bu nesnelerin yönetiminde zorlanabiliriz. Bu sebeple, <strong>node</strong> türündeki <strong>spatial</strong> ları kullanacağız. Hatırlarsanız, <strong>spatial</strong> ların belirli bir konumu oluyordu, diğer nesnelerimizi bu <strong>node</strong> lara yerleştireceğiz. <strong>node</strong> spatial’ları nested özelliğine sahip yani <strong>parent</strong> ve <strong>child</strong> node lar tanımlayabilirsiniz. Varsayılan olarak bu kurgumuzda <strong>base node</strong> üzerine diğer node ları ve spatial ları ekleyeceğiz.<p>Örnek vermek gerekirse;<ul><li>rootNode <ul><li>playerNode <ul><li>aimNode<li>armNode</ul><li>envNode <ul><li>houseNode<li>marketNode</ul></ul></ul><p>Bu konuda hazırlanan şu slayt da oldukça bilgi verici: <a href=https://wiki.jmonkeyengine.org/tutorials/scenegraph/assets/fallback/index.html rel=noopener target=_blank>3D Scene Graph for Dummies</a></div><br><a class=button href=https://github.com/erayaydin/zola-personal-blog/blob/main/content/blog/2020-03-22-kotlin-jmonkeyengine-oyun-gelistirme-tanimlar.md>Contribute to this post</a><hr><script async crossorigin issue-term=pathname label=💬 repo=erayaydin/erayaydin.github.io src=https://utteranc.es/client.js theme=preferred-color-scheme></script></main><footer><hr><div><div><p>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a>, theme inspired from <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a>.</div><div><a rel="noopener noreferrer" title="Subscribe via RSS for updates." class=no-style href=https://era.yayd.in/atom.xml target=_blank><svg class=icons><use href=https://era.yayd.in/icons.svg#rss></use></svg></a></div></div></footer><script defer src=https://era.yayd.in/app.js></script>